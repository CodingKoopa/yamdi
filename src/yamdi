#!/bin/sh

# Quit on error.
set -e

# Exits YAMDI, saving the patch for any changes that have been made to the configuration files by
# the server. If the Java process seems to have crashed, the patch will not be created.
# Arguments:
#   - The Java return code.
# Outputs:
#   - Status messages.
# Returns:
#   - The same Java return code.
# Variables Read:
#   - SERVER_CONFIG_HOST_DIRECTORY: Location of the mountpoint of the host's configuration
# directory.
#   - SERVER_DIRECTORY: Location of the containerized server directory.
exit_script() {
  java_ret=$1
  readonly java_ret

  info "Exiting Yet Another Minecraft Docker Image."

  if [ "$java_ret" -ne 0 ]; then
    warning "Java process return code is $java_ret, likely crashed. Not checking files for changes."
  else
    info "Java process return is 0. Checking files for changes."

    info "Checking server configuration files."
    get_directory_changes "$SERVER_CONFIG_HOST_DIRECTORY" "$SERVER_DIRECTORY" \
      "$SERVER_DIRECTORY/config.patch"
    info "Checking server plugin files."
    get_directory_changes "$SERVER_PLUGINS_HOST_DIRECTORY" "$SERVER_DIRECTORY/plugins" \
      "$SERVER_DIRECTORY/plugins.patch"
  fi

  exit "$java_ret"
}

# Stops the server, and exits the script. This function can handle SIGINT and SIGTERM signals. This
# function needs "utils.sh" to be sourced.
# Arguments:
#   - The name of the signal received.
# Outputs:
#   - Status messages.
# Variables Read:
#   - JAVA_PID: The PID of the Java process.
stop() {
  info "$1 recieved."
  if [ -n "$JAVA_PID" ]; then
    info "Server is running with PID $JAVA_PID, sending stop command."
    # Send the "stop" command to the server.
    cmd stop
    # Take over the job of quitting YAMDI, as the code at the end of this script won't be executed
    # as it normally would.
    info "Waiting for Java process to exit."
    set +e
    wait "$JAVA_PID"
    java_ret=$?
    set -e
    exit_script $java_ret
  else
    info "It looks like the server was never started. Exiting without further action."
    exit 0
  fi
}

# Handle the SIGINT and SIGTERM signals. SIGINT is what is normally sent to a program when Ctrl+C
# is pressed. The server handles this by quitting, without saving. SIGTERM is what is sent to a
# program when "docker stop" or "docker-compose" is used. SIGTERM is also used when an active
# Docker Compose session is quit with Ctrl+C (This does not work in regular Docker.).

# SIGINT and SIGTERM are expected to implemented similarly. The server implements them by shutting
# down the server, but without saving. The "stop" Bukkit command shuts down the server properly,
# and does save everything, so here the signals are trapped, and will intervene to run the "stop"
# command.
trap "stop SIGINT" INT
trap "stop SIGTERM" TERM

# shellcheck source=src/yamdi-utils
. yamdi-utils

info "Starting Yet Another Minecraft Docker Image."

# Setup variables that are expected to be set.

# Print and capture the Java version.
info "Java version:"
java_version_info=$(java -version)
readonly java_version_info
# Determine which JVM implementation this Java installation uses.
if [ "${java_version_info#*OpenJ9}" != "$java_version_info" ]; then
  jvm_impl="openj9"
else
  jvm_impl="hotspot"
fi
readonly jvm_impl

# TODO: After set -u is fixed, have this be = false.
if [ ! "$YAMDI_SKIP_VOLUME_CHECK" = true ] && [ -f $SERVER_DIRECTORY/volume-not-mounted ]; then
  error "There doesn't seem to be a Docker volume mounted to $SERVER_DIRECTORY! This means none of \
the server data will persist once this container is gone. This likely isn't want you want, exiting."
  exit 1
fi

# Remove files that aren't depended upon by any stage of this script.
if [ "$YAMDI_CLEAN_FILES" = true ]; then
  debug "Cleaning crash dumps and reports."
  # Purge crash dumps.
  rm -rf heapdump.* javacore.* Snap.*
  # Purge crash reports and logs. With Docker, we have our own logging system.
  rm -rf crash-reports logs ./*.log
fi

info "Importing server configuration files."
import_directory "$SERVER_CONFIG_HOST_DIRECTORY" "$SERVER_DIRECTORY"
# Ignore server properties unless explicitly told not to.
if [ ! "$YAMDI_IGNORE_SERVER_PROPERTY_CHANGES" = false ]; then
  # Allow this to fail, for the case in which we haven't setup a host config directory.
  git update-index --assume-unchanged "$SERVER_DIRECTORY/server.properties" 2>/dev/null || true
fi

if [ -d "$SERVER_DIRECTORY/plugins" ]; then
  # If we aren't doing a clean, don't go any further than the root JARs. If we do go further, then
  # JARs in subdirectories will be cleaned, mostly consisting of plugin dependency JARs.
  if [ ! "$YAMDI_CLEAN_FILES" = true ]; then
    _shallow=true
    readonly _shallow
  fi
  # Delete pre-existing JARs because, otherwise they will persist when/if new JARs are added.
  find "$SERVER_DIRECTORY/plugins" ${_shallow:+-maxdepth 1} -name "*.jar" -type f -delete
fi
info "Importing server plugin files."
import_directory "$SERVER_PLUGINS_HOST_DIRECTORY" "$SERVER_DIRECTORY/plugins"

# This is necessary because of Spigot BuildTools needing to use Git.
debug "Unsetting Git variables."
unset GIT_DIR GIT_WORK_TREE

if [ -z "$YAMDI_SERVER_TYPE" ]; then
  YAMDI_SERVER_TYPE="spigot"
fi
if [ -z "$YAMDI_MINECRAFT_VERSION" ]; then
  YAMDI_MINECRAFT_VERSION="latest"
fi

if [ "$YAMDI_SERVER_TYPE" = "spigot" ]; then
  info "Spigot server selected."

  server_jar="$SERVER_DIRECTORY/spigot.jar"
  readonly server_jar
  spigot_revision_jar="$SERVER_DIRECTORY/spigot-$YAMDI_MINECRAFT_VERSION.jar"
  readonly spigot_revision_jar
  server_name="Spigot-$YAMDI_MINECRAFT_VERSION"
  readonly server_name

  # Only build a new spigot.jar if manually enabled, or if a jar for this REV does not already
  # exist.
  if [ "$FORCE_SPIGOT_REBUILD" = true ] || [ ! -f "$spigot_revision_jar" ]; then
    debug "Building $server_name."
    # Build in a temporary directory.
    spigot_build_directory=/tmp/spigot-build
    readonly spigot_build_directory
    mkdir -p "$spigot_build_directory"
    (
      cd "$spigot_build_directory"
      # Remove any preexisting JARs from failed compilations.
      rm -f BuildTools.jar
      # Download the latest BuildTools JAR.
      curl -O "https://hub.spigotmc.org/jenkins/job/BuildTools/lastSuccessfulBuild/\
artifact/target/BuildTools.jar"

      buildtools_memory_opts=$(generate_memory_opts "$YAMDI_BUILDTOOLS_MEMORY_AMOUNT_MIN" \
        "$YAMDI_BUILDTOOLS_MEMORY_AMOUNT_MAX" "$YAMDI_BUILDTOOLS_MEMORY_AMOUNT")
      readonly buildtools_memory_opts
      total_buildtools_memory_opts="$buildtools_memory_opts $YAMDI_JVM_OPTS"
      readonly total_buildtools_memory_opts

      # Run BuildTools with the specified RAM, for the specified revision.
      # shellcheck disable=SC2086
      java $total_buildtools_memory_opts -jar BuildTools.jar --rev $YAMDI_MINECRAFT_VERSION
      # Copy the Spigot build to the Spigot directory.
      cp spigot-*.jar "$spigot_revision_jar"
    )

    # Remove the build files to preserve space.
    rm -rf "$spigot_build_directory"
  else
    debug "$server_name already built."
  fi

  # Select the specified revision. In some cases, ln's -f option doesn't work.
  rm -rf "$server_jar"
  ln -s "$spigot_revision_jar" "$server_jar"

elif [ $YAMDI_SERVER_TYPE = "paper" ]; then
  info "Paper server selected."

  server_jar="$SERVER_DIRECTORY/paper.jar"
  readonly server_jar
  if [ -z "$YAMDI_PAPER_BUILD" ]; then
    YAMDI_PAPER_BUILD="latest"
  fi

  # Disable exit on error so that we can handle curl errors.
  set +e

  # Handles errrors produced by curl, by printing a common message, and exiting.
  # Outputs:
  #   - Any errors produced.
  # Returns:
  #   - Exits with 2 if any curl error has immediately occurred before this command.
  handle_curl_errors() {
    curl_ret=$?
    if [ "$curl_ret" -ne 0 ]; then
      error "Failed to connect to Paper servers. Curl error code: \"$curl_ret\""
      exit 2
    fi
  }

  # Unlike Spigot, the Paper launcher doesn't know what to do with a "latest" version, so here we
  # manually find out the latest version using the API. When we do have the latest version, if a
  # "latest" build was specified (or omitted altogether) then we have to find out that too.
  if [ "$YAMDI_MINECRAFT_VERSION" = "latest" ]; then
    debug "Resolving latest Paper revision."

    versions_json=$(curl -s https://papermc.io/api/v2/projects/$YAMDI_SERVER_TYPE)
    readonly versions_json

    handle_curl_errors
    version_json_error=$(echo "$versions_json" | jq .error)
    readonly version_json_error
    if [ ! "null" = "$version_json_error" ]; then
      error "Failed to fetch Paper versions. Curl error: \"$version_json_error\"."
      exit 2
    fi

    YAMDI_MINECRAFT_VERSION=$(echo "$versions_json" | jq .versions[-1] | sed s/\"//g)
  fi
  debug "Paper revision: \"$YAMDI_MINECRAFT_VERSION\"."

  if [ "$YAMDI_PAPER_BUILD" = "latest" ]; then
    debug "Resolving latest Paper build."
    builds_json=$(curl -s \
      "https://papermc.io/api/v2/projects/$YAMDI_SERVER_TYPE/versions/$YAMDI_MINECRAFT_VERSION")
    readonly builds_json

    handle_curl_errors
    builds_json_error=$(echo "$builds_json" | jq .error)
    readonly builds_json_error
    if [ ! "null" = "$builds_json_error" ]; then
      error "Failed to fetch Paper build info. Curl error: \"$builds_json_error\"."
      exit 2
    fi

    YAMDI_PAPER_BUILD=$(echo "$builds_json" | jq .builds[-1] | sed s/\"//g)
  fi
  debug "Paper build: \"$YAMDI_PAPER_BUILD\"."

  debug "Resolving Paper build name."
  build_json=$(curl -s "https://papermc.io/api/v2/projects/$YAMDI_SERVER_TYPE/\
versions/$YAMDI_MINECRAFT_VERSION/builds/$YAMDI_PAPER_BUILD")
  readonly build_json

  handle_curl_errors
  build_json_error=$(echo "$build_json" | jq .error)
  readonly builds_json_error
  if [ ! "null" = "$build_json_error" ]; then
    error "Failed to fetch Paper build info. Curl error: \"$build_json_error\"."
    exit 2
  fi

  paper_build_jar_name=$(echo "$build_json" | jq .downloads.application.name | sed s/\"//g)
  readonly paper_build_jar_name

  paper_revision_jar="$SERVER_DIRECTORY/\
$YAMDI_SERVER_TYPE-$YAMDI_MINECRAFT_VERSION-$YAMDI_PAPER_BUILD.jar"
  readonly paper_revision_jar
  server_name="Paper-$YAMDI_MINECRAFT_VERSION-$YAMDI_PAPER_BUILD"
  readonly server_name
  if [ ! -f "$paper_revision_jar" ]; then
    debug "Downloading $server_name."
    curl "https://papermc.io/api/v2/projects/$YAMDI_SERVER_TYPE/versions/$YAMDI_MINECRAFT_VERSION/builds/\
$YAMDI_PAPER_BUILD/downloads/$paper_build_jar_name" >"$paper_revision_jar"
    handle_curl_errors
  else
    debug "$server_name already downloaded."
  fi

  # Resume exit on error.
  set -e

  # Select the specified revision. In some cases, ln's -f option doesn't work.
  rm -rf "$server_jar"
  ln -sf "$paper_revision_jar" "$server_jar"
fi

if [ ! -f "$server_jar" ]; then
  error "Error: Server JAR not found. This could be due to a build error, or a misconfiguration."
  exit 1
fi

# Perform server JAR cleanup.
if [ "$YAMDI_CLEAN_FILES" = true ]; then
  find "$SERVER_DIRECTORY" -maxdepth 1 \
    \( -name "*.jar" ! -name "$(basename "$(readlink "$server_jar")")" \) -type f -delete
fi

# Make sure the command input file is clear.
rm -f "$COMMAND_INPUT_FILE"
# Make a named pipe for sending commands to the server. It is important that the permissions are
# 700 because, if they were world writeable, any user could run a server command with administrator
# priviledges.
mkfifo -m700 "$COMMAND_INPUT_FILE"

game_memory_opts=$(generate_memory_opts "$YAMDI_GAME_MEMORY_AMOUNT_MIN" \
  "$YAMDI_GAME_MEMORY_AMOUNT_MAX" "$YAMDI_GAME_MEMORY_AMOUNT")
readonly game_memory_opts

# Append suggested JVM options unless required not to.
if [ ! "$YAMDI_USE_SUGGESTED_JVM_OPTS" = false ]; then
  if [ "$jvm_impl" = "hotspot" ]; then
    # Set the error file path to include the server info.
    suggested_jvm_opts="$suggested_jvm_opts -XX:ErrorFile=./$server_name-error-pid%p.log"

    # Enable experimental VM features, for the options we'll be setting. Although this is not
    # listed in the documentation for "java", when I tested an experimental feature in a YAMDI
    # container, this was necessary. These options are largely taken from here:
    # https://mcflags.emc.gs/.
    suggested_jvm_opts="$suggested_jvm_opts -XX:+UnlockExperimentalVMOptions"

    # Ensure that the G1 garbage collector is enabled, because in some cases it isn't the default.
    suggested_jvm_opts="$suggested_jvm_opts -XX:+UseG1GC"
    # Don't reserve memory, because this option seems to break and cause OOM errors when running in
    # Docker.
    # suggested_jvm_opts="$suggested_jvm_opts -XX:+AlwaysPreTouch"
    # Disable explicit garbage collection, because some plugins try to manage their own memory and
    # suck at it.
    suggested_jvm_opts="$suggested_jvm_opts -XX:+DisableExplicitGC"
    # Adjust the max size of the new generation that will be set later.
    suggested_jvm_opts="$suggested_jvm_opts -XX:G1MaxNewSizePercent=80"
    # Lower the garbage collection threshold, to make cleanups not as demanding.
    suggested_jvm_opts="$suggested_jvm_opts -XX:G1MixedGCLiveThresholdPercent=35"
    # Raise the New Generation size to keep up with MC's allocations, because MC has many.
    suggested_jvm_opts="$suggested_jvm_opts -XX:G1NewSizePercent=50"
    # Take 100ms at the most to collect garbage.
    suggested_jvm_opts="$suggested_jvm_opts -XX:MaxGCPauseMillis=100"
    # Allow garbage collection to use multiple threads, for performance.
    suggested_jvm_opts="$suggested_jvm_opts -XX:+ParallelRefProcEnabled"
    # Set the garbage collection target survivor ratio higher to use more of the survivor space
    # before promoting it, because MC has steady allocations.
    suggested_jvm_opts="$suggested_jvm_opts -XX:TargetSurvivorRatio=90"
  elif [ "$jvm_impl" = "openj9" ]; then
    # These options are largely taken from here:
    # https://steinborn.me/posts/tuning-minecraft-openj9/.
    # See the utility script for the generation of the nursery limits.

    # Enable pausless garbage collection, for smaller pause times.
    suggested_jvm_opts="$suggested_jvm_opts -Xgc:concurrentScavenge"
    # Reduce the amount of time spent collecting the nursery.
    suggested_jvm_opts="$suggested_jvm_opts -Xgc:dnssExpectedTimeRatioMaximum=3"
    # Ensure that nursery objects aren't promoted to the nursery too quickly, since the server will
    # be making many of them.
    suggested_jvm_opts="$suggested_jvm_opts -Xgc:scvNoAdaptiveTenure"
    # Disable explicit garbage collection, for the same reason as in hotspot.
    suggested_jvm_opts="$suggested_jvm_opts -Xdisableexplicitgc"
  fi
fi

total_game_jvm_opts="$game_memory_opts $suggested_jvm_opts $YAMDI_JVM_OPTS"
readonly total_game_jvm_opts
info "Launching Java process for $server_name with JVM options \"$total_game_jvm_opts\"."
# Start the launcher with the options we've put together, while feeding it input from the named
# pipe. Execute it in the background, so we can still handle signals, and manage the "tail" process.
# shellcheck disable=SC2086
tail -f $COMMAND_INPUT_FILE | java $total_game_jvm_opts -jar "$server_jar" nogui &
export JAVA_PID=$!
# Start a background subshell that we can use to monitor the background process.
(
  # Wait for the Java process to exit.
  while kill -0 $JAVA_PID 2>/dev/null; do sleep 1; done
  # Kill the "tail" process that feeds commands to the "java" process. Without doing this, if the
  # "java" process exits, then the "tail" process will continue to exist. Since we're using POSIX
  # sh, we can't use process substitution or the pipefail option to alleviate this, as recommmended
  # here (https://stackoverflow.com/a/53382807), so we need to kill it ourselves.
  #
  # The reason why we care about killing the "tail" process is that, if we don't do so, then the
  # "wait" command will wait indefinitely.
  killall tail
) &
info "Waiting for Java process (PID $JAVA_PID) to exit."
# Allow wait to return an error without making the whole script exit.
set +e
# Wait for the Java process to exit. This may seem redundant with the prior while loop; the purpose
# of this one is to capture the exit code, which is useful to determine whether the process exited
# peacefully.
wait $JAVA_PID
java_ret=$?
set -e
debug "Java process exited (return $java_ret)."
exit_script $java_ret
