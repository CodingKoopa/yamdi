variables:
  YAMDI_DOCKER_REGISTRY:
    description: "URL of the Docker registry to use."
    # The v2 registry seems to have authentication issues when used here.
    value: "https://index.docker.io/v1/"
  YAMDI_DOCKER_USER:
    description: "Username of the registry user."
  YAMDI_DOCKER_PASS:
    description: "Password of the registry user."
  YAMDI_DOCKER_IMAGE:
    description: "Image to push to."

# Define the stages.
stages:
  # Create a static code analysis stage.
  - analyze
  # Create an app package building stage. There is no separate deploy stage, because docker buildx
  # doesn't have any built in support for building a multi-arch image manifest, and deploying it
  # later. Relevant GitHub issues:
  # - https://github.com/docker/buildx/issues/166
  # - https://github.com/docker/buildx/issues/430
  - build

editorconfig-checker:
  # Add to the analysis stage.
  stage: analyze
  # Use the latest ec Docker image.
  image: mstruebing/editorconfig-checker:latest
  # Check that all text complies with the EditorConfig file.
  script: ec

shfmt:
  stage: analyze
  # Use the latest Alpine Linux shfmt Docker image.
  image: mvdan/shfmt:latest-alpine
  rules:
    - changes:
        # Watch for changes in the source.
        - "src/*"
  # Check that all Bash code has proper formatting.
  script: shfmt -d .

shellcheck:
  stage: analyze
  # Use the latest stable ShellCheck Docker image.
  image: koalaman/shellcheck-alpine:stable
  rules:
    - changes:
        - "src/*"
  # Check that all Bash code is proper.
  script: shellcheck --external-sources *.sh

build:
  # Add to the build stage.
  stage: build
  # Run in our Docker in Docker (dind) + buildx plugin image.
  image: yamdi/dind-buildx
  services:
    # Enable the dind service.
    - docker:dind
  script:
    # Just to be safe, initialize the variable we'll be using to store arguments.
    - args="";
    # If we are running on the default branch.
    - if [ "$CI_COMMIT_BRANCH" = "$CI_DEFAULT_BRANCH" ]; then
    # Log into the Docker registry.
    - |
      echo "$YAMDI_DOCKER_PASS" | docker login "$YAMDI_DOCKER_REGISTRY" \
      --username "$YAMDI_DOCKER_USER" --password-stdin
    # Append the push argument.
    - args="$args --push"; fi
    # If we are building for any architectures other than our own.
    - if [ "$CI_RUNNER_EXECUTABLE_ARCH" != "$YAMDI_ARCH" ]; then
    # Create a new builder instance whose driver will support multi-arch building.
    - docker buildx create --use;
    # Configure binfmt_misc to use QEMU. This is necessary to fix this issue:
    # https://github.com/docker/buildx/issues/584
    - docker run --rm --privileged multiarch/qemu-user-static --reset -p yes; fi
    # Retrieve the date from the predefined CI datetime variable.
    - date=$(printf %s "$CI_PIPELINE_CREATED_AT" | cut -dT -f1 | tr -d -)
    # Iterate over the tags specified. The default IFS delimiter includes spaces.
    - for tag in $YAMDI_TAGS; do
    # # Construct the tag arguments.
    - args="$args --tag $YAMDI_DOCKER_IMAGE:$tag --tag $YAMDI_DOCKER_IMAGE:$tag-$date"; done
    # Build and push the images.
    - |
      docker buildx build --build-arg YAMDI_BASE_IMAGE="$YAMDI_BASE_IMAGE" \
      --platform="$YAMDI_ARCH" $args .
  parallel:
    matrix:
      - YAMDI_BASE_IMAGE: adoptopenjdk/openjdk16:jre
        YAMDI_ARCH: linux/amd64,linux/arm64,linux/arm
        YAMDI_TAGS: latest latest-ubuntu adoptopenjdk-jre16-ubuntu
      - YAMDI_BASE_IMAGE: adoptopenjdk/openjdk16:alpine-jre
        YAMDI_ARCH: linux/amd64
        YAMDI_TAGS: latest-alpine adoptopenjdk-jre16-alpine
