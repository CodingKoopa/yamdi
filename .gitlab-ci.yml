# Privately defined variables:
# - YAMDI_DOCKER_REGISTRY: The URL of the Docker registry to use.
# - YAMDI_DOCKER_USER: The username of the registry user to sign in with.
# - YAMDI_DOCKER_PASS: The password of the registry user to sign in with.
# - YAMDI_DOCKER_IMAGE: The image of the registry to push to.

# Define the Docker in Docker template.
.dind:
  variables:
    # Set the Docker host to the network connection to the dind service instead of the usual socket.
    DOCKER_HOST: tcp://docker:2375/
  # Run in our Docker in Docker w/ buildx image.
  image: yamdi/dind-buildx
  services:
    # Enable the Docker service.
    - docker:dind
  before_script:
    # If we are running on a protected branch or tag.
    - if [ "$CI_COMMIT_REF_PROTECTED" = true ]; then
    # Log into the Docker registry.
    - |
      echo "$YAMDI_DOCKER_PASS" | docker login "$YAMDI_DOCKER_REGISTRY" \
      --username "$YAMDI_DOCKER_USER" --password-stdin; fi

# Define the stages.
stages:
  # Create a static code analysis stage.
  - analyze
  # Create an app package building stage. There is no separate deploy stage, because docker buildx
  # doesn't have any built in support for building a multi-arch image manifest, and deploying it
  # later. Relevant GitHub issues:
  # - https://github.com/docker/buildx/issues/166
  # - https://github.com/docker/buildx/issues/430
  - build

ec:
  # Add to the analysis stage.
  stage: analyze
  # Use the latest ec Docker image.
  image: mstruebing/editorconfig-checker:latest
  # Check that all text complies with the EditorConfig file.
  script: ec

shfmt:
  stage: analyze
  # Use the latest Alpine Linux shfmt Docker image.
  image: mvdan/shfmt:latest-alpine
  rules:
    - changes:
        # Watch for changes in the YAMDI scripts.
        - "*.sh"
        # Watch for changes in the CI scripts.
        - "CI/*.sh"
  # Check that all Bash code has proper formatting.
  script: shfmt -d .

shellcheck:
  stage: analyze
  # Use the latest stable ShellCheck Docker image.
  image: koalaman/shellcheck-alpine:stable
  rules:
    - changes:
        - "*.sh"
        - "CI/**/*.sh"
  # Check that all Bash code is proper.
  script: shellcheck --external-sources *.sh

# Define the Docker image building template.
.docker-build:
  extends: .dind
  # Any Docker image building will be a part of the package building stage, so do so here.
  stage: build
  script:
    - set +x
    # If we are building for any architectures other than our own.
    - if [ "$CI_RUNNER_EXECUTABLE_ARCH" != "$YAMDI_ARCH" ];
    # Create a new builder instance whose driver will support multi-arch building.
    - then docker buildx create --use; fi
    # Retrieve the date from the predefined CI datetime variable.
    - date=$(printf %s "$CI_PIPELINE_CREATED_AT" | cut -dT -f1)
    # Iterate over the tags specified. The default IFS delimiter includes spaces.
    - for tag in $YAMDI_TAGS; do
    # # Construct the tag arguments.
    - tag_args="$tag_args --tag $YAMDI_DOCKER_IMAGE:$tag --tag $YAMDI_DOCKER_IMAGE:$tag-$date"; done
    # Build and push the images.
    - |
      docker buildx build --build-arg YAMDI_BASE_IMAGE=\"$YAMDI_BASE_IMAGE\" $tag_args \
      --platform=\"$YAMDI_ARCH\" --push

adoptopenjdk-jre16-alpine:
  extends: .docker-build
  variables:
    YAMDI_BASE_IMAGE: adoptopenjdk/openjdk16:alpine-jre
    YAMDI_ARCH: linux/amd64
    YAMDI_TAGS: latest-alpine adoptopenjdk-jre16-alpine
